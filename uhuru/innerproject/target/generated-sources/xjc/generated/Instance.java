//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.02.27 at 06:26:30 PM GMT 
//


package generated;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.datatype.XMLGregorianCalendar;
import org.jvnet.hyperjaxb3.item.ItemUtils;
import org.jvnet.hyperjaxb3.xml.bind.annotation.adapters.XMLGregorianCalendarAsDateTime;
import org.jvnet.hyperjaxb3.xml.bind.annotation.adapters.XmlAdapterUtils;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element ref="{}NUMHUS"/>
 *         &lt;element ref="{}COURSEID"/>
 *         &lt;element ref="{}OWNINST" minOccurs="0"/>
 *         &lt;element ref="{}COMDATE"/>
 *         &lt;element ref="{}ENDDATE"/>
 *         &lt;element ref="{}HEAPESPOP" minOccurs="0"/>
 *         &lt;element ref="{}LOCATION" maxOccurs="10" minOccurs="0"/>
 *         &lt;element ref="{}RSNEND" minOccurs="0"/>
 *         &lt;element ref="{}SPLENGTH"/>
 *         &lt;element ref="{}UNITLGTH"/>
 *         &lt;element ref="{}InstancePeriod" maxOccurs="unbounded"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "numhus",
    "courseid",
    "owninst",
    "comdate",
    "enddate",
    "heapespop",
    "location",
    "rsnend",
    "splength",
    "unitlgth",
    "instancePeriod"
})
@XmlRootElement(name = "Instance")
@Entity(name = "Instance")
@Table(name = "INSTANCE")
@Inheritance(strategy = InheritanceType.JOINED)
public class Instance
    implements Serializable, Equals, HashCode
{

    @XmlElement(name = "NUMHUS", required = true)
    protected String numhus;
    @XmlElement(name = "COURSEID", required = true)
    protected String courseid;
    @XmlElement(name = "OWNINST")
    protected String owninst;
    @XmlElement(name = "COMDATE", required = true)
    protected XMLGregorianCalendar comdate;
    @XmlElement(name = "ENDDATE", required = true)
    protected String enddate;
    @XmlElement(name = "HEAPESPOP")
    protected HEAPESPOPCodeType heapespop;
    @XmlElement(name = "LOCATION")
    protected List<String> location;
    @XmlElement(name = "RSNEND")
    protected RSNENDCodeType rsnend;
    @XmlElement(name = "SPLENGTH", required = true)
    protected String splength;
    @XmlElement(name = "UNITLGTH", required = true)
    protected UNITLGTHCodeType unitlgth;
    @XmlElement(name = "InstancePeriod", required = true)
    protected List<InstancePeriod> instancePeriod;
    @XmlTransient
    protected Long hjid;
    protected transient List<InstanceLOCATIONItem> locationItems;

    /**
     * Gets the value of the numhus property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    @Basic
    @Column(name = "NUMHUS", length = 20)
    public String getNUMHUS() {
        return numhus;
    }

    /**
     * Sets the value of the numhus property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setNUMHUS(String value) {
        this.numhus = value;
    }

    /**
     * Gets the value of the courseid property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    @Basic
    @Column(name = "COURSEID", length = 30)
    public String getCOURSEID() {
        return courseid;
    }

    /**
     * Sets the value of the courseid property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setCOURSEID(String value) {
        this.courseid = value;
    }

    /**
     * Gets the value of the owninst property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    @Basic
    @Column(name = "OWNINST", length = 30)
    public String getOWNINST() {
        return owninst;
    }

    /**
     * Sets the value of the owninst property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setOWNINST(String value) {
        this.owninst = value;
    }

    /**
     * Gets the value of the comdate property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    @Transient
    public XMLGregorianCalendar getCOMDATE() {
        return comdate;
    }

    /**
     * Sets the value of the comdate property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setCOMDATE(XMLGregorianCalendar value) {
        this.comdate = value;
    }

    /**
     * Gets the value of the enddate property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    @Basic
    @Column(name = "ENDDATE")
    public String getENDDATE() {
        return enddate;
    }

    /**
     * Sets the value of the enddate property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setENDDATE(String value) {
        this.enddate = value;
    }

    /**
     * Gets the value of the heapespop property.
     * 
     * @return
     *     possible object is
     *     {@link HEAPESPOPCodeType }
     *     
     */
    @ManyToOne(targetEntity = HEAPESPOPCodeType.class, cascade = {
        CascadeType.ALL
    }, fetch = FetchType.EAGER)
    @JoinColumn(name = "HEAPESPOP")
    public HEAPESPOPCodeType getHEAPESPOP() {
        return heapespop;
    }

    /**
     * Sets the value of the heapespop property.
     * 
     * @param value
     *     allowed object is
     *     {@link HEAPESPOPCodeType }
     *     
     */
    public void setHEAPESPOP(HEAPESPOPCodeType value) {
        this.heapespop = value;
    }

    /**
     * Gets the value of the location property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the location property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLOCATION().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    @Transient
    public List<String> getLOCATION() {
        if (location == null) {
            location = new ArrayList<String>();
        }
        return this.location;
    }

    /**
     * 
     * 
     */
    public void setLOCATION(List<String> location) {
        this.location = location;
    }

    /**
     * Gets the value of the rsnend property.
     * 
     * @return
     *     possible object is
     *     {@link RSNENDCodeType }
     *     
     */
    @ManyToOne(targetEntity = RSNENDCodeType.class, cascade = {
        CascadeType.ALL
    }, fetch = FetchType.EAGER)
    @JoinColumn(name = "RSNEND")
    public RSNENDCodeType getRSNEND() {
        return rsnend;
    }

    /**
     * Sets the value of the rsnend property.
     * 
     * @param value
     *     allowed object is
     *     {@link RSNENDCodeType }
     *     
     */
    public void setRSNEND(RSNENDCodeType value) {
        this.rsnend = value;
    }

    /**
     * Gets the value of the splength property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    @Basic
    @Column(name = "SPLENGTH", scale = 0)
    public String getSPLENGTH() {
        return splength;
    }

    /**
     * Sets the value of the splength property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSPLENGTH(String value) {
        this.splength = value;
    }

    /**
     * Gets the value of the unitlgth property.
     * 
     * @return
     *     possible object is
     *     {@link UNITLGTHCodeType }
     *     
     */
    @ManyToOne(targetEntity = UNITLGTHCodeType.class, cascade = {
        CascadeType.ALL
    }, fetch = FetchType.EAGER)
    @JoinColumn(name = "UNITLGTH")
    public UNITLGTHCodeType getUNITLGTH() {
        return unitlgth;
    }

    /**
     * Sets the value of the unitlgth property.
     * 
     * @param value
     *     allowed object is
     *     {@link UNITLGTHCodeType }
     *     
     */
    public void setUNITLGTH(UNITLGTHCodeType value) {
        this.unitlgth = value;
    }

    /**
     * Gets the value of the instancePeriod property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the instancePeriod property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInstancePeriod().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InstancePeriod }
     * 
     * 
     */
    @OneToMany(targetEntity = InstancePeriod.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "INSTANCEPERIOD_INSTANCE__HJID")
    public List<InstancePeriod> getInstancePeriod() {
        if (instancePeriod == null) {
            instancePeriod = new ArrayList<InstancePeriod>();
        }
        return this.instancePeriod;
    }

    /**
     * 
     * 
     */
    public void setInstancePeriod(List<InstancePeriod> instancePeriod) {
        this.instancePeriod = instancePeriod;
    }

    /**
     * 
     * 
     * @return
     *     possible object is
     *     {@link Long }
     *     
     */
    @Id
    @Column(name = "hjid")
    @GeneratedValue(strategy = GenerationType.AUTO)
    public Long gethjid() {
        return hjid;
    }

    /**
     * 
     * 
     * @param value
     *     allowed object is
     *     {@link Long }
     *     
     */
    public void sethjid(Long value) {
        this.hjid = value;
    }

    @Basic
    @Column(name = "COMDATEITEM")
    @Temporal(TemporalType.TIMESTAMP)
    public Date getCOMDATEItem() {
        return XmlAdapterUtils.unmarshall(XMLGregorianCalendarAsDateTime.class, this.getCOMDATE());
    }

    public void setCOMDATEItem(Date target) {
        setCOMDATE(XmlAdapterUtils.marshall(XMLGregorianCalendarAsDateTime.class, target));
    }

    @OneToMany(targetEntity = InstanceLOCATIONItem.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "LOCATIONITEMS_INSTANCE__HJID")
    public List<InstanceLOCATIONItem> getLOCATIONItems() {
        if (this.locationItems == null) {
            this.locationItems = new ArrayList<InstanceLOCATIONItem>();
        }
        if (ItemUtils.shouldBeWrapped(this.location)) {
            this.location = ItemUtils.wrap(this.location, this.locationItems, InstanceLOCATIONItem.class);
        }
        return this.locationItems;
    }

    public void setLOCATIONItems(List<InstanceLOCATIONItem> value) {
        this.location = null;
        this.locationItems = null;
        this.locationItems = value;
        if (this.locationItems == null) {
            this.locationItems = new ArrayList<InstanceLOCATIONItem>();
        }
        if (ItemUtils.shouldBeWrapped(this.location)) {
            this.location = ItemUtils.wrap(this.location, this.locationItems, InstanceLOCATIONItem.class);
        }
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof Instance)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final Instance that = ((Instance) object);
        {
            String lhsNUMHUS;
            lhsNUMHUS = this.getNUMHUS();
            String rhsNUMHUS;
            rhsNUMHUS = that.getNUMHUS();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "numhus", lhsNUMHUS), LocatorUtils.property(thatLocator, "numhus", rhsNUMHUS), lhsNUMHUS, rhsNUMHUS)) {
                return false;
            }
        }
        {
            String lhsCOURSEID;
            lhsCOURSEID = this.getCOURSEID();
            String rhsCOURSEID;
            rhsCOURSEID = that.getCOURSEID();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "courseid", lhsCOURSEID), LocatorUtils.property(thatLocator, "courseid", rhsCOURSEID), lhsCOURSEID, rhsCOURSEID)) {
                return false;
            }
        }
        {
            String lhsOWNINST;
            lhsOWNINST = this.getOWNINST();
            String rhsOWNINST;
            rhsOWNINST = that.getOWNINST();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "owninst", lhsOWNINST), LocatorUtils.property(thatLocator, "owninst", rhsOWNINST), lhsOWNINST, rhsOWNINST)) {
                return false;
            }
        }
        {
            XMLGregorianCalendar lhsCOMDATE;
            lhsCOMDATE = this.getCOMDATE();
            XMLGregorianCalendar rhsCOMDATE;
            rhsCOMDATE = that.getCOMDATE();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "comdate", lhsCOMDATE), LocatorUtils.property(thatLocator, "comdate", rhsCOMDATE), lhsCOMDATE, rhsCOMDATE)) {
                return false;
            }
        }
        {
            String lhsENDDATE;
            lhsENDDATE = this.getENDDATE();
            String rhsENDDATE;
            rhsENDDATE = that.getENDDATE();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "enddate", lhsENDDATE), LocatorUtils.property(thatLocator, "enddate", rhsENDDATE), lhsENDDATE, rhsENDDATE)) {
                return false;
            }
        }
        {
            HEAPESPOPCodeType lhsHEAPESPOP;
            lhsHEAPESPOP = this.getHEAPESPOP();
            HEAPESPOPCodeType rhsHEAPESPOP;
            rhsHEAPESPOP = that.getHEAPESPOP();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "heapespop", lhsHEAPESPOP), LocatorUtils.property(thatLocator, "heapespop", rhsHEAPESPOP), lhsHEAPESPOP, rhsHEAPESPOP)) {
                return false;
            }
        }
        {
            List<String> lhsLOCATION;
            lhsLOCATION = (((this.location!= null)&&(!this.location.isEmpty()))?this.getLOCATION():null);
            List<String> rhsLOCATION;
            rhsLOCATION = (((that.location!= null)&&(!that.location.isEmpty()))?that.getLOCATION():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "location", lhsLOCATION), LocatorUtils.property(thatLocator, "location", rhsLOCATION), lhsLOCATION, rhsLOCATION)) {
                return false;
            }
        }
        {
            RSNENDCodeType lhsRSNEND;
            lhsRSNEND = this.getRSNEND();
            RSNENDCodeType rhsRSNEND;
            rhsRSNEND = that.getRSNEND();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "rsnend", lhsRSNEND), LocatorUtils.property(thatLocator, "rsnend", rhsRSNEND), lhsRSNEND, rhsRSNEND)) {
                return false;
            }
        }
        {
            String lhsSPLENGTH;
            lhsSPLENGTH = this.getSPLENGTH();
            String rhsSPLENGTH;
            rhsSPLENGTH = that.getSPLENGTH();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "splength", lhsSPLENGTH), LocatorUtils.property(thatLocator, "splength", rhsSPLENGTH), lhsSPLENGTH, rhsSPLENGTH)) {
                return false;
            }
        }
        {
            UNITLGTHCodeType lhsUNITLGTH;
            lhsUNITLGTH = this.getUNITLGTH();
            UNITLGTHCodeType rhsUNITLGTH;
            rhsUNITLGTH = that.getUNITLGTH();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "unitlgth", lhsUNITLGTH), LocatorUtils.property(thatLocator, "unitlgth", rhsUNITLGTH), lhsUNITLGTH, rhsUNITLGTH)) {
                return false;
            }
        }
        {
            List<InstancePeriod> lhsInstancePeriod;
            lhsInstancePeriod = (((this.instancePeriod!= null)&&(!this.instancePeriod.isEmpty()))?this.getInstancePeriod():null);
            List<InstancePeriod> rhsInstancePeriod;
            rhsInstancePeriod = (((that.instancePeriod!= null)&&(!that.instancePeriod.isEmpty()))?that.getInstancePeriod():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "instancePeriod", lhsInstancePeriod), LocatorUtils.property(thatLocator, "instancePeriod", rhsInstancePeriod), lhsInstancePeriod, rhsInstancePeriod)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = 1;
        {
            String theNUMHUS;
            theNUMHUS = this.getNUMHUS();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "numhus", theNUMHUS), currentHashCode, theNUMHUS);
        }
        {
            String theCOURSEID;
            theCOURSEID = this.getCOURSEID();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "courseid", theCOURSEID), currentHashCode, theCOURSEID);
        }
        {
            String theOWNINST;
            theOWNINST = this.getOWNINST();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "owninst", theOWNINST), currentHashCode, theOWNINST);
        }
        {
            XMLGregorianCalendar theCOMDATE;
            theCOMDATE = this.getCOMDATE();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "comdate", theCOMDATE), currentHashCode, theCOMDATE);
        }
        {
            String theENDDATE;
            theENDDATE = this.getENDDATE();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "enddate", theENDDATE), currentHashCode, theENDDATE);
        }
        {
            HEAPESPOPCodeType theHEAPESPOP;
            theHEAPESPOP = this.getHEAPESPOP();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "heapespop", theHEAPESPOP), currentHashCode, theHEAPESPOP);
        }
        {
            List<String> theLOCATION;
            theLOCATION = (((this.location!= null)&&(!this.location.isEmpty()))?this.getLOCATION():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "location", theLOCATION), currentHashCode, theLOCATION);
        }
        {
            RSNENDCodeType theRSNEND;
            theRSNEND = this.getRSNEND();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "rsnend", theRSNEND), currentHashCode, theRSNEND);
        }
        {
            String theSPLENGTH;
            theSPLENGTH = this.getSPLENGTH();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "splength", theSPLENGTH), currentHashCode, theSPLENGTH);
        }
        {
            UNITLGTHCodeType theUNITLGTH;
            theUNITLGTH = this.getUNITLGTH();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "unitlgth", theUNITLGTH), currentHashCode, theUNITLGTH);
        }
        {
            List<InstancePeriod> theInstancePeriod;
            theInstancePeriod = (((this.instancePeriod!= null)&&(!this.instancePeriod.isEmpty()))?this.getInstancePeriod():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "instancePeriod", theInstancePeriod), currentHashCode, theInstancePeriod);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

}
